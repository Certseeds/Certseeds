<!--
 * @Github: https://github.com/Certseeds/words
 * @Organization: SUSTech
 * @Author: nanoseeds
 * @Date: 2021-08-11 23:10:21
 * @LastEditors: nanoseeds
 * @LastEditTime: 2021-08-13 00:16:40
   * @License: CC-BY-NC-SA_V4_0 or any later version 
   -->

  # Effective Java阅读笔记

## Chapter 2 创建与销毁对象

### 2-1 使用静态方法取代构造器

1. 可以带名称. number.problemPrime(min,max)比number(min,max,random)+注释的方式容易理解的多.
2. 可以在调用时缓存对象. 比如Boolean.valueOf(boolean)其实只会返回两个对象,一个True,一个False.
3. 可以返回子类型的对象. 这一点在`List.of()`中体现的最为突出,其返回值的类型为`ListN<E>`,继承于`AbstractImmutableList -> AbstractImmutableCollection -> AbstractCollection -> Collection`,实现了List<E>接口.
4. 返回的对象的类可以随着每次调用发生变化. 这一条在`List.of()`中也非常明显,在无参数,参数大于两个时,返回值的类型时`ListN<E>`,但是当只有一个或者两个参数时,返回值的类型为`List12<E>`,在继承关系上与`ListN<E>`平级.
5. 方法返回的对象所属的类,在编写包含该静态方法所属的类的时候可以不存在. 返回的类可以通过依赖注入等方式进行构造.

自JDK9以来的List.of(),Map.of(),Set.of()等方法提供了比之前final static静态导入安全得多,直观的多的不可变对象,值得JDK8为之升级.

### 2-2 多个构造器参数时要考虑使用构建器(Builder)

当一个类具有多个参数,并且多个初始化时有些参数是可选项,会导致这个类产生多个参数数量不一致的构造函数,在某些更糟糕的情况下,甚至会出现多个参数数量不一致或是参数数量一致,但是参数类型顺序不一致,又或是参数类型不已知的构造方法.在这种情况下,标明在构造函数参数列表内的参数名就是几乎唯一的标志.

这样只会带来毁灭性的效果,当IDE自动提示出多种选择时,难以根据这些参数混乱不堪的构造函数构造出想要的对象.

当然,还有一些方式可以改进,

首先,可以将所有含参构造函数去掉,强制只使用无参构造函数与setter为对象赋值,当然,这样的效果也很差,参数越多行数越多,看起来乱糟糟一篇,打扰心情;

倘若再进步一些,便可以为setter的返回值设为`this`,从而允许链式赋值.

但是无论怎么改进,这种方式得到的对象里的值全都*不*是*不可变量*,影响安全.

在这里可以使用Build模式,在Object中嵌入一个Builder,来实现类中字段的final与灵活赋值兼顾.

### 2-3 私有构造器或者枚举类型强化Singleton.

常见的单例构造需要考虑是否懒加载,是否线程安全,但是还要考虑的是,反射以及反序列化时是否会影响单例,反射可以通过私有构造器抛出异常来阻止调用私有构造器,反序列化可以通过重写`readResolve()`来解决问题,但是归根结底,还是使用枚举类实现的成本最低,使用Java内部的机制,又能带来安全,解决反序列化/反射带来的问题.

### 2-4 私有构造器强化不可实例化

Java中没有独立的函数,即使是static函数也必须依附于一个类,如果这个类中的所有方法都是static方法,那么这个类的实例化实际上是无意义的,我们希望能够禁止对其进行实例化.

单纯的不写任何构造函数只会令JDK产生一个public的无参构造函数,手写一个private的构造函数又有被内部调用的风险,所以只能在private中直接加入throw Exception来解决.

实际上这个问题的答案更可能是Java的语法问题,C++中有指定的构造函数=delete功能,只要构造函数加上`=delete();`后缀,便会在编译时删去这个函数,从而令对其的调用在编译期就失败,从而从根本上解决问题.

### 2-5 优先通过依赖注入来引用资源

实际上这一条实现后,更方便与依赖注入框架合作来实现功能,同时也间接方便2-1.

### 2-6 避免创建不必要的对象

就像Boolean实际上只需要两个对象一样,不可变对象可以被重用,越是昂贵的对象就越应该考虑静态初始化,甚至直接做成枚举值.

### 2-7 消除过期的对象引用.

这一条更多出现在自定义的容器中,比如一个内部由数组实现的栈,其如果进行pop操作后没有对pop对应位置的对象标为null的话,实际上容器仍然持有其引用,会导致垃圾回收受阻.

### 2-8 避免使用终结方法与清楚方法

终结方法: `finalize()`
清楚方法: 继承自`Cleanable`,实现`clean()`方法.

问题在于执行时间不确定,不像析构函数,对于栈上对象来说调用的时间是确定的.而且严格来讲,不保证执行,甚至完全不执行也符合JVM做出的承诺(正如一个抛弃所有包-丢包率稳定100%的UDP协议也是符合协议内容的一样).

终结方法看上去可以被`System.gc`,`System.runFinalization`所强制调用,但是还是那句话,JVM完全可以无视其存在.至于确保可以调用的API已经被废弃了,不应该进行任何访问.

终结方法甚至会吃掉其中可能存在的异常堆栈信息.

终结方法性能拉跨,还会出现安全问题-防止攻击的办法是实现空的final的finalize方法(没感觉有哪几个实现了?也许lombok有对应注解)

也就两种情况下适合使用,第一本地不重要的一些资源,第二本地无法被GC的Native-Object.

### 2-9 try-with-resource优于try-catch

try-with-resource提供了一种类似C++中RAII的使用体验,在try()中new的对象会被编译器自动添加的finally块中调用`close()`,类似于用finally实现的析构方法.

很显然的是,既然try-with-resource背后由编译期自动生成,还是自动调用的Finally块,那么实际上try-finally没有手动实现的必要了,要做的只是把所有的资源实现`Closeable`接口.

