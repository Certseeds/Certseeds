<!--
 * @Github: https://github.com/Certseeds/words
 * @Organization: SUSTech
 * @Author: nanoseeds
 * @Date: 2021-08-29 21:30:33
 * @LastEditors: nanoseeds
 * @LastEditTime: 2021-08-29 23:48:46
 * @License: CC-BY-NC-SA_V4_0 or any later version 
 -->

# 小型团队 合作最佳实践

小型团队: 开全体会议只需要一张桌子的团队. (PS:请不要考虑什么联合国巨型圆桌)

团队合作内容: 涉及到多端的项目,通常既有前端,也有后端,必要时也有客户端.

## 确定需求

无论是什么项目,一般情况下需求侧提供的都只是简易的`方案`,描述出的是最终用户使用的效果,游戏之类只会说`我们希望做一个抽卡游戏`,web只会有`我们想要一个评测网站,目的是给导师评分`这类模糊的需求.

更进一步的说,可能会给出一些硬性的要求,比如`必须提供充值功能(接入支付宝,微信)`,`必须要支持多用户,既要接入CAS系统,支持学生实名匿名评分,又要令管理员能够图形化操作后台`,但是,提供的也就仅限于此了.

给出更多的还是基本原则(模糊的需求),通常情况下,硬性要求都是基本原则的直接延伸. 这对于一个系统来讲远远不够.

所以,第一件事应该是根据给定的基本原则&&硬性要求,确定项目的全部需求.

### 确定用户

首先,项目的终端使用者到底是谁? 这直接与项目的根本需求相关.

比如一个`**评价网`,用户更多是一般通过路人,单纯就看两眼统计数据;只有核心用户才会登录,实名或者匿名发表一些看法;管理员是`训练有素的运维工程师`,完全可以不依靠GUI维护网站.

这种情况下,确认了用户是`一般通过路人`&&`具有发表欲,并且想保护自己隐私的核心用户`. 现在才能对需求作进一步的细化.

PS: 有时这一步会被指定,那也没办法了.

### 确定需求列表

确定用户后,才能开始拆解需求,在填入基本需求的情况下,对基本原则进行拆解,扩展出根本的需求.

### 将需求变换为GUI

最终的产品都要以GUI形式呈现,而这并不是单纯的前端工程师的工作,而是需要所有人一起来决定的重要步骤.

为什么? 因为需要从用户的角度来做出判断,专业的人偏向于专业视角,可能会把一些设计当作理所应当,忽略了一般人的视角.

并且,在这一步需要确认 GUI的用户遍历图, 不仅要确认每个页面的第一状态,并且要对每个页面的`变化`做出考虑,将这些页面的状态之间的流向联系成一张图,并且确认变化之间的条件,动画与反馈.

这一点目的是从用户视角确认需求的可行性,提前预演用户使用链路,避免过于复杂,没人能用得到,或者过于微小,没人能注意到的功能.

### 定稿

这一步完成之后,最终使用用户已经确定,需求的具体小项已经以固定下来,并且以GUI的形式展现,GUI间还有变更图.

## 进行开发

上一步完结之后,需求定稿了,接下来开发人员该入场发挥专业知识了.

### 确定API

这一步实际上与GUI强相关,前后端需要根据GUI的展示与变化,制定API,基本原则:每一个`展示`与`变更`都要关联上对应的API.

与此同时,整个API文档需要放在**所有开发人员**都能看得到的地方,并且也要确保所有人**完全**按照API进行开发.

#### 需求变更了! **W*\**F**

虽然不想承认,但是有时需求就是会发生变化. 这种时候,**首先**停止开发,拉取前后端所有人重新对API,保证API文档按GUI进行编写后,再进行开发,不然只能是浪费时间.

### 按API进行开发

实际上的建立仓库最迟到这一步开始.

小型团队就没必要搞monorepo了,规模还没大到需要使用这种手段.

#### 搭建框架

这一步建议一个人搞,框架搭建很容易出现冲突,并且个人之间的倾向不一致,容易发生问题.

包括但不限于: pom.xml编写,设计分层,设计异常处理逻辑等等.

#### 规范管理

上一步完成之后,在github或者gitlab上应该已经存在了一个仓库,其中只有一个master分支,有零散的几次提交.

##### 代码格式化管理

Go连代码如何格式化都内置到了语言内部,其他语言很难实现这一点,幸运的是,总是有办法实现的.

C++系项目有clang-format,Java有formatter插件,又或者在确认开发IDE统一的情况下,可以将IDE配置文件(只是格式相关的,不是全部)上传到仓库内.

有了这些格式化工具,该怎么确认提交时运行了呢?

git提供了一些钩子,但是这些钩子没办法配置到版本管理中,有什么解决办法?

使用前端工具链的`husky`(显然依赖node),显式的声明pre-commit钩子,这样就能确保 格式化工具一定在提交前进行.

##### TODO