---
author: "Certseeds"
date: "2022-04-23"
title: "2022-04-23 words"
description: "something words in 2022-04-23"
tags: ["experience"]
---

# 20220423杂谈

## 代码质量管理

假设一个内网环境中,存在复数个代码管理平台,将这些代码管理平台按提交后合入主干分支的难易程度排列.

gerrit默认就处于一个比较高的位置,其代码提交后会触发其他平台的测试(如jenkins)来+1,需要经过人工review来+2;
gitlab可以设置在一个比较高的位置,代码提交后会触发流水线(当然,流水线服务不是凭空产生的,而是需要提供宿主机的)执行测试,测试结束之后才有合入的资格; 同时也可以设置合入时的最小review人数以及必须review才能合入的人

从代码质量管理角度来看,越严密的合入条件越能保证代码质量; 但是过多的步骤会大幅度降低代码合入速度,如果长期无法在质量-开发速度间平衡, 这个严格的平台很可能被架空,团队中的成员转而向更自由,开发速度更快的平台.

因此, 更严格的一方应该通过更高效的GUI界面,全容器化部署环境准备-自动部署, 更加高效的触发机制(push/pr/tag), 更加有效的GUI代码review机制来取胜. 同时还要注意取舍,将不必要的,容易出错的功能完全舍去.

1. 更高效的GUI界面, 此处包括但不限于"目录式文件查看","代码在线词法分析染色","在线语法分析-关键词跳转",代码类型自动标注 等功能, 尽量减少将其拉去下来进行review的必要.
2. 更加高效的触发机制: push,发出pr,打上tag应该能触发不同的动作: push后需要测试;pr合入需要进行覆盖率检查,质量检查;tag需要打包,将包推送到某个平台.
3. 更有效地代码-review: 是否能基于行甚至基于圈定词组来注解,注解双方是否能形成对话链.

PS: 当然,以上问题github都能解决

## 基础设施与核心功能

经常能见到一些人以"实现简单"为由, 通过一些傻大黑粗的功能来实现主流程; 比如在spring框架已经很完善的前提下,手搓servlet搭 restful服务 ; 配置文件不用spring的读取,就要自己手动读文件; 更有甚者手搓丐版json解析. 这些人里有的是想炫技,没想到别人只把他当◼◼; 有的是是真◼◼,担心代码写得少,显得自己功劳少; 也不排除某些人真正◼◼, 只会servlet,硬着头皮写垃圾.

当然不是这些实现方式无法实现功能,而是它们繁琐,麻烦,因为是自定义,所以没人为其背书,没人负责, 更别提重复性高-从而带来出错概率也高. 这些基础设置一旦维护成本高,就会极大的影响项目的变更成本-从而将整个项目拖入低质量代码的泥潭.

总结来说, 基础设置应该简单,易于理解,容易拓展并且互相解耦; 从而能使项目的变更成本尽量降低, 方便代码的重构,重写.

## 无状态的测试与仓库驱动的测试

有容器之后,测试可以全程在容器中进行,容器通过和外界环境隔离,提供了一个干净的环境-在这种情况下, 如果能实现"无状态"的测试,那么测试就能在服务端,在本地都能执行. 这样可以极大程度的提高问题复现速度,提高开发速度.

无状态当然也不是完全的无状态,完全可以依赖环境中的某些条件存在. 但是其依赖关系必须梳理清楚,明确环境中容器节点的部署顺序,测试容器依赖一系列环境容器,环境容器又有一层层的部署关系,部署时自动按依赖链条进行部署.

测试存在多种驱动方式,GitHub Actions推崇的是仓库驱动的测试,测试内容基于仓库内的特定文件; gerrit这种老旧平台是仓库无关的测试,测试部分由测试人员负责,甚至测试部分可以单独拉成一个仓库.

仓库驱动的测试本质是相信开发人员-或者相信reviewer内测试人员把控力度,好处在于将测试纳入版本管理,整体便于复现; 仓库无关的测试会把测试过程和仓库分离开,仓库无法将测试步骤纳入版本管理, 两者割裂开来. 

## 版本管理

版本管理不仅要管理版本,还要管理版本产物.

有些仓库的产物是能公开发布的软件包, 是容器镜像, 或者是浏览器拓展- 这种情况下其产物有对应的位置, 公开发布的软件包将被推送到npm,mvn-center,pypi, docker-hub,chrome商店. 这种情况下,版本产物的管理相当于被托管给了其他的平台.

但是某些仓库的产物是私有的,不能公开发布的软件包, 是对全平台的二进制软件包, 是需要走脚本处理的Header-only库: 这些产物不能,或者没有途径让第三方管理. 这个时候仓库就需要负起管理责任.

有些人会把这些通过脚本的方式, 在发版时将其自动生成并推送到特定分支(一个永远只有一个最新提交的分支,保留太多历史分支太耗空间了); 有些人会采用独立的仓库来存储这些二进制产物.

https://github.com/Kitware/CMake/releases/download/v3.23.1/cmake-3.23.1-files-v1.json

这里GitHub提供的处理方式同样精彩, 它们先管理版本产物这件事限定到了发版时,也就是Tag上, 再以`https://github.com/${UserName}/${RepoName}/releases/tag/${TagName}`这个网址为基础,
将Tag下的文件对应到URL`https://github.com/${UserName}/${RepoName}/releases/download/${TagName}/${fileName}` 这个路径上, 一个四元组决定一个对象链接,背后依托对象存储服务来提供.
