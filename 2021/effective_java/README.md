<!--
 * @Github: https://github.com/Certseeds/words
 * @Organization: SUSTech
 * @Author: nanoseeds
 * @Date: 2021-08-11 23:10:21
 * @LastEditors: nanoseeds
 * @LastEditTime: 2021-08-19 23:08:06
   * @License: CC-BY-NC-SA_V4_0 or any later version 
   -->

# Effective Java阅读笔记

## Chapter 02 创建与销毁对象

### 02-1 使用静态方法取代构造器

1. 可以带名称. number.problemPrime(min,max)比number(min,max,random)+注释的方式容易理解的多.
2. 可以在调用时缓存对象. 比如Boolean.valueOf(boolean)其实只会返回两个对象,一个True,一个False.
3. 可以返回子类型的对象. 这一点在`List.of()`中体现的最为突出,其返回值的类型为`ListN<E>`,继承于`AbstractImmutableList -> AbstractImmutableCollection -> AbstractCollection -> Collection`,实现了List<E>接口.
4. 返回的对象的类可以随着每次调用发生变化. 这一条在`List.of()`中也非常明显,在无参数,参数大于两个时,返回值的类型时`ListN<E>`,但是当只有一个或者两个参数时,返回值的类型为`List12<E>`,在继承关系上与`ListN<E>`平级.
5. 方法返回的对象所属的类,在编写包含该静态方法所属的类的时候可以不存在. 返回的类可以通过依赖注入等方式进行构造.

自JDK9以来的List.of(),Map.of(),Set.of()等方法提供了比之前final static静态导入安全得多,直观的多的不可变对象,值得JDK8为之升级.

### 02-2 多个构造器参数时要考虑使用构建器(Builder)

当一个类具有多个参数,并且多个初始化时有些参数是可选项,会导致这个类产生多个参数数量不一致的构造函数,在某些更糟糕的情况下,甚至会出现多个参数数量不一致或是参数数量一致,但是参数类型顺序不一致,又或是参数类型不已知的构造方法.在这种情况下,标明在构造函数参数列表内的参数名就是几乎唯一的标志.

这样只会带来毁灭性的效果,当IDE自动提示出多种选择时,难以根据这些参数混乱不堪的构造函数构造出想要的对象.

当然,还有一些方式可以改进,

首先,可以将所有含参构造函数去掉,强制只使用无参构造函数与setter为对象赋值,当然,这样的效果也很差,参数越多行数越多,看起来乱糟糟一篇,打扰心情;

倘若再进步一些,便可以为setter的返回值设为`this`,从而允许链式赋值.

但是无论怎么改进,这种方式得到的对象里的值全都*不*是*不可变量*,影响安全.

在这里可以使用Build模式,在Object中嵌入一个Builder,来实现类中字段的final与灵活赋值兼顾.

### 02-3 私有构造器或者枚举类型强化Singleton.

常见的单例构造需要考虑是否懒加载,是否线程安全,但是还要考虑的是,反射以及反序列化时是否会影响单例,反射可以通过私有构造器抛出异常来阻止调用私有构造器,反序列化可以通过重写`readResolve()`来解决问题,但是归根结底,还是使用枚举类实现的成本最低,使用Java内部的机制,又能带来安全,解决反序列化/反射带来的问题.

PS: 这里当然不是指的enum内嵌一个class或是class内嵌一个enum,而是指这个class本身把类型定义成enum.

### 02-4 私有构造器强化不可实例化

Java中没有独立的函数,即使是static函数也必须依附于一个类,如果这个类中的所有方法都是static方法,那么这个类的实例化实际上是无意义的,我们希望能够禁止对其进行实例化.

单纯的不写任何构造函数只会令JDK产生一个public的无参构造函数,手写一个private的构造函数又有被内部调用的风险,所以只能在private中直接加入throw Exception来解决.

实际上这个问题的答案更可能是Java的语法问题,C++中有指定的构造函数`=delete`功能,只要构造函数加上`=delete;`后缀,便会在编译时删去这个函数,从而令对其的调用在编译期就失败,从而从根本上解决问题.

### 02-5 优先通过依赖注入来引用资源

实际上这一条实现后,更方便与依赖注入框架合作来实现功能,同时也间接方便02-1.

### 02-6 避免创建不必要的对象

就像Boolean实际上只需要两个对象一样,不可变对象可以被重用,越是昂贵的对象就越应该考虑静态初始化,甚至直接做成枚举值.

### 02-7 消除过期的对象引用.

这一条更多出现在自定义的容器中,比如一个内部由数组实现的栈,其如果进行pop操作后没有对pop对应位置的对象标为null的话,实际上容器仍然持有其引用,会导致垃圾回收受阻.

### 02-8 避免使用终结方法与清除方法

终结方法: `finalize()`
清除方法: 继承自`Cleanable`,实现`clean()`方法.

问题在于执行时间不确定,不像析构函数,对于栈上对象来说调用的时间是确定的.而且严格来讲,不保证执行,甚至完全不执行也符合JVM做出的承诺(正如一个抛弃所有包-丢包率稳定100%的UDP协议也是符合协议内容的一样).

终结方法看上去可以被`System.gc`,`System.runFinalization`所强制调用,但是还是那句话,JVM完全可以无视其存在.至于确保可以调用的API已经被废弃了,不应该进行任何访问.

终结方法甚至会吃掉其中可能存在的异常堆栈信息.

终结方法性能拉跨,还会出现安全问题-防止攻击的办法是实现空的final的finalize方法(没感觉有哪几个实现了?也许lombok有对应注解)

也就两种情况下适合使用,第一本地不重要的一些资源,第二本地无法被GC的Native-Object.

### 2-9 try-with-resource优于try-catch

try-with-resource提供了一种类似C++中RAII的使用体验,在try()中new的对象会被编译器自动添加的finally块中调用`close()`,类似于用finally实现的析构方法.

很显然的是,既然try-with-resource背后由编译期自动生成,还是自动调用的Finally块,那么实际上try-finally没有手动实现的必要了,要做的只是把所有的资源实现`Closeable`接口.

## Chapter 12 序列化

### 12-1 序列化*问题很大*

序列化过程中,如果只涉及基本类型及其包装类型的话,当然较为安全,但是一旦涉及到包装类,如HashMap,HashSet等类,很容易被意想不到的方式攻击

最典型的莫过于HashMap嵌套问题,

假设有2n+1个对象,</br>
根对象左节点,右节点分别为1st,2nd</br>
1st的左节点为3rd,右节点4th,而2nd的左右节点与1st相同</br>
3rd的左节点为5th,右节点6th,而4th的左右节点与3st相同</br>
相当于每一层只有两个节点,但是每一层的每个节点都被上一层的每个节点当作左节点或右节点.
这样层层嵌套下去,只需要2n+1个对象,就构造出了高达2^n个对象,导致时间爆炸.

解决方案是什么呢?
答案是使用json等简单格式,但是json是怎么处理嵌套问题攻击呢?

答案是没有处理,但是json格式如果对应上述的层层嵌套对象,那么首先对应的 需要解析的字符串就会超级长,在这一点上,json格式无法表达引用这一点反而成为了优势,因为这强迫使得json格式的输入规模与输出规模相匹配,反序列化炸弹自己在输入规模上就露馅了.
*PS:fastjson似乎有引用这一feature,很好奇他们对此的意见*

由于反序列化这一过程涉及到了完全无法预计的引用,所以最好**不要使用**反序列化,应该用json或者protobuf代替.

替代不了的可以用白名单过滤,只允许那些可信任的类,只序列化那些可信任的数据.

### 12-2 Serializable 谨慎实现

Serializable实现之后,其序列化的形式就变成了对外接口的一部分,如果没有良好的设计,那么这个隐式的对外接口将会为后续的开发带来麻烦.

Serializable这种接口只有标记作用,其中没有默认实现,但是又有与其行为绑定的序列化,反序列化函数,这些隐式实现的函数(尤其是反序列化函数)是隐藏的构造器,很容易反序列化出不符合标准的对象.

为了继承设计的类应该尽量少的实现Serializable接口,用户接口也应该尽量少的实现Serializable接口,避免迫使使用者实现.

Serializable只在可信环境+可控数据下较为安全,不要将其作为对外交互的任何方式.

PS: Serializable接口的设计太失败了,至少也得有`writeObject`,`readObject`,`getSerialVersionUID`这三个方法吧.
PSS: 其实还是设计的锅,Interface之前没办法加入默认实现,所以没办法把这些方法加到接口内.现在积重难返 

### 12-3 使用自定义的序列化形式

其实可以类比成,既然序列化形式应该尽量不使用,那么我们可以把序列化的格式转化成json,反序列化也是从json中反序列化,直接把所有属性都标明` transient`,全部手动转换.

### 12-4 使用保护性的`readObject`,`validateObject`

令readObject中对输入数据进行复制再赋值,并调用`validateObject()`对对象做校验,更一般的是,可以令构造函数也调用`validateObject()`,简化逻辑

### 12-5 示例控制-枚举优先于readResolve

这一项有可能有点绕口,但是无论如何,单例的实现都应该用枚举类型.

+ 构造器
+ 反射
+ 反序列化
+ Clone,

1. PS: `Cloneable`接口是公认的不推荐使用,一般根本不会有人主动实现`clone()`方法,不需要考虑.

2. 反射我们将私有构造器抛出异常来实现初级的防御,但是总是会有一个构造器不抛出异常,如果被反射调用了还是会被破坏,怎么办呢?

答案是标志位,当然,其实标志位也是防君子不防小人的,反射完全可以修改私有字段来实现对flag的屏蔽.

由此可见,反射的攻击相当难办,最好还是想点别的办法.

3. 反序列化,反序列化可以通过`readResolve()`来防御,但是这也是防君子不防小人,可以构造出序列化的流,其中将类的字段以`fake`类来代替,`fake`类内又引用类,`fake`类的`readResolve()`又返回被代替的字段的值,实现对反序列化的攻击.当然,最终的解决办法是不在类中放置任何可被藏身的字段-给所有字段加以`transient`,但是这样问题又来了,这样还搞什么序列化呢?

4. 构造器的攻击显然可以被忽略

由此可见,如果要实现一个单例,要考虑的事情几乎是无限的,还是JDK内置的enum靠谱

### 12-6 考虑使用序列化代理代替序列化实例

类内嵌一个proxy静态内部类,令外部类的`writeReplace()`(PS: 又一个接口里不提但是明显与接口有关的特殊方法)返回这个proxy静态代理类的示例,之后序列化生成的就是这个代理类,然后这个代理类的`readResolove()`调用外部类的构造器,来保证安全性.好处就是把`readObject`可以彻底放弃了,反序列化也导向了构造器,外部类自身也可以设置为final.

PS: 与单例无关

PSS: 再次统计一下,Serializable接口的设计真的太失败了,至少也得有`getSerialVersionUID`,`readObject`,`writeObject`,`readResolve()`,`writeReplace()`这五个方法吧.

### TODO

注: 发布于GitHub的本文采取CC-BY-NC-SA-4.0 or any later version,保留在其他平台采取不同许可证的权利-转发链路不同导致的许可证不同问题,请通过到源发布平台转发来解决.
