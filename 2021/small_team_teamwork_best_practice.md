---
author: "Certseeds"
license: "CC-BY-NC-SA-4.0 or any later version"
date: "2021-08-29"
title: "小型团队合作最佳实践"
description: "small team teamwork best practice"
tags: ["experience"]
---

# 小型团队 合作最佳实践

小型团队: 开全体会议只需要一张桌子的团队. (PS:请不要考虑什么联合国巨型圆桌)

团队合作内容: 涉及到多端的项目,通常既有前端,也有后端,必要时也有客户端.

## 确定需求

无论是什么项目,一般情况下需求侧提供的都只是简易的`方案`,描述出的是最终用户使用的效果,游戏之类只会说`我们希望做一个抽卡游戏`,web只会有`我们想要一个评测网站,目的是给导师评分`这类模糊的需求.

更进一步的说,可能会给出一些硬性的要求,比如`必须提供充值功能(接入支付宝,微信)`,`必须要支持多用户,既要接入CAS系统,支持学生实名匿名评分,又要令管理员能够图形化操作后台`,但是,提供的也就仅限于此了.

给出更多的还是基本原则(模糊的需求),通常情况下,硬性要求都是基本原则的直接延伸. 这对于一个系统来讲远远不够.

所以,第一件事应该是根据给定的基本原则&&硬性要求,确定项目的全部需求.

### 确定用户

首先,项目的终端使用者到底是谁? 这直接与项目的根本需求相关.

比如一个`**评价网`,用户更多是一般通过路人,单纯就看两眼统计数据;只有核心用户才会登录,实名或者匿名发表一些看法;管理员是`训练有素的运维工程师`,完全可以不依靠GUI维护网站.

这种情况下,确认了用户是`一般通过路人`&&`具有发表欲,并且想保护自己隐私的核心用户`. 现在才能对需求作进一步的细化.

PS: 有时这一步会被指定,那也没办法了.

### 确定需求列表

确定用户后,才能开始拆解需求,在填入基本需求的情况下,对基本原则进行拆解,扩展出根本的需求.

### 将需求变换为GUI

最终的产品都要以GUI形式呈现,而这并不是单纯的前端工程师的工作,而是需要所有人一起来决定的重要步骤.

为什么? 因为需要从用户的角度来做出判断,专业的人偏向于专业视角,可能会把一些设计当作理所应当,忽略了一般人的视角.

并且,在这一步需要确认 GUI的用户遍历图, 不仅要确认每个页面的第一状态,并且要对每个页面的`变化`做出考虑,将这些页面的状态之间的流向联系成一张图,并且确认变化之间的条件,动画与反馈.

这一点目的是从用户视角确认需求的可行性,提前预演用户使用链路,避免过于复杂,没人能用得到,或者过于微小,没人能注意到的功能.

### 定稿

这一步完成之后,最终使用用户已经确定,需求的具体小项已经以固定下来,并且以GUI的形式展现,GUI间还有变更图.

## 进行开发

上一步完结之后,需求定稿了,接下来开发人员该入场发挥专业知识了.

### 确定API

这一步实际上与GUI强相关,前后端需要根据GUI的展示与变化,制定API,基本原则:每一个`展示`与`变更`都要关联上对应的API.

与此同时,整个API文档需要放在**所有开发人员**都能看得到的地方,并且也要确保所有人**完全**按照API进行开发.

#### 需求变更了! **W*\**F**

虽然不想承认,但是有时需求就是会发生变化. 这种时候,**首先**停止开发,拉取前后端所有人重新对API,保证API文档按GUI进行编写后,再进行开发,不然只能是浪费时间.

### 按API进行开发

实际上的建立仓库最迟到这一步开始.

小型团队就没必要搞monorepo了,规模还没大到需要使用这种手段.

#### 搭建框架

这一步建议一个人搞,框架搭建很容易出现冲突,并且个人之间的倾向不一致,容易发生问题.

包括但不限于: pom.xml编写,设计分层,设计异常处理逻辑等等.

#### 规范管理

上一步完成之后,在github或者gitlab上应该已经存在了一个仓库,其中只有一个master分支,有零散的几次提交.

##### 代码格式化管理

很少有语言像Go一样,连代码如何格式化都内置了,幸运的是,总是第三方实现的.

C++系项目有clang-format,Java有formatter插件,又或者在确认开发IDE统一的情况下,可以将IDE配置文件(只是格式相关的,不是全部)上传到仓库内.

有了这些格式化工具,该怎么确认提交时运行了呢?

git提供了一些钩子,但是这些钩子没办法配置到版本管理中,有什么解决办法?

使用前端工具链的`husky`(显然依赖node),显式的声明pre-commit钩子,这样就能确保 格式化工具一定在提交前进行.

#### 配置文件管理

将配置文件放到仓库中是一个很常见的操作,一般会以"方便持续集成"的借口来实现,但是其实这是非常没有前瞻性的一项操作.

举个最简单的例子,如果想用GitHub actions做自动部署,使用SSH服务把文件推送到某个服务器上,这时候可以选择把密钥存到仓库内,或者在GitHub repo的后台配置一个变量.

一旦选择将密钥存到仓库内,意味着以后万一有 把代码仓库 给别人看的情况,就相当于向他开放了服务器权限! 其他人只是想看代码实现,并不想承担服务器被攻击的黑锅,为了可能的分享机会,不要把任何私密相关的配置文件放到仓库内.

##### 两套配置文件

虽然说不能将私密的配置文件放到仓库内,但是有时候就是需要一个配置文件方便CI,怎么办呢?

使用两套配置文件吧

在`resource`底下放一套最基本的,不会泄露隐私的作为fallback选项

在根目录下放一个`config`文件夹,里面放一个 从项目开始就加入了 `.gitignore` 的配置文件,这个里面放少量的,隐私相关的,但是又 **不会** 进入版本管理的配置项(记得写到README里,免得有人忘记)

这样的好处在于分割了易变项和不变项,将无关紧要的不变项存储起来,机密的易变项本地管理,分而治之.

PS: 这样做的前提在于 存在覆盖选项, 即

+ 高优先级的配置文件的配置项, 可以覆盖低优先级的配置项
+ 高优先级的配置文件内没有配置的, 就加载低优先级配置文件内的配置项

如果只有全或无的覆盖的话,就只有保护数据安全的作用了.

PSS: 如果配置项更多,可以使用另一个private仓库来存储配置文件,利用这个仓库本身,不再赘述

#### 持续集成

频繁的,涉及到所有提交,所有变更的持续集成是加速开发流程的必要手段,这个系统越明确,越容易感知,起的作用就越好.

这里以GitHub Actions为例,展示财大气粗的GitHub是怎么实现体验绝佳的持续集成系统的.

##### 无缝集成

通过了GitHub Actions的提交

+ 首页中部, `${commit Hash} ${Date} ${* commits}`的左方多一个小小的绿色对勾,没通过则是一个小红色叉号.
+ 查看提交详情时,会在提交记录左侧有一个小绿色对勾,没通过也是红叉
+ Pull Request页面最下方会有一个列表,记录CI是否通过.

这些小细节能够让人即使不知道持续集成的细节,也能轻松了解内部的情况.

###### 仓库相关的声明式配置

Github Actions的配置全部依赖于仓库内指定位置的配置文件,真正做到了"声明式",避免了配置项与仓库之间关联性的问题,

也方便GitHub 中的fork->PR工作流,使得fork一方可以获取原仓库的CI配置.

###### 性能强劲

GitHub Actions的Liunx端每个实例,默认配置单核双线程,内存7G,最大执行时间6小时,同时可并发10个示例. 并且公有仓库,Actions现在不收取费用. 不得不说,背靠微软,GitHub确实财大气粗.

###### 复用配置

GitHub Actions提供了将操作打包成 Actions的功能,可以轻易的复用他人封装好的操作,实现复杂的配置(比如启动另一个redis容器,配置Mysql环境),节约了自己配制的时间.

#### Code Review

Code Review显然不是指 重复看自己的代码,而是指看别人的代码,判断正确性,思考是否可以优化,避免出现漏洞.

##### 得有别人的代码

Code Review最好形成一种习惯,而又可以用规律性动作来形成习惯,比如理想情况下,自己开始开发之前,先Review其他人的代码.但是,这也产生了问题,如果大家都两三天甚至一个星期发一个PR,这种低频下该怎么实现规律的Code Review呢?

PS: 此时使用fork模式的好处就出现了, 大家各自fork出一个仓库,自己建一个分支,开始有第一个提交之后就建立`[Work In Progress]`Pull-Request,一方面声明自己在做什么,一方面利用Actions做持续集成,另一方面向所有人公示自己的进度,方便Code Review

又或者,将功能拆分,尽量聚焦于完整功能,完成一个提交一次.

##### 让持续集成确保正确性,Code Review负责其他的

功能方面的测试应该交由持续集成来实现,Code Review的前提是通过了持续集成-没通过回去继续改,通过了之后,再继续审阅.

现有测试下的正确性应该让自动化流程验证,让人的精力聚焦于更有意义的事情上.

#### 测试环境

测试环境应该和生产环境相同-即使平台不同,也要确保服务相同-不要出于炫技,搞个内存数据库用于测试,MySQL用于生产环境.