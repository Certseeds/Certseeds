## Chapter 05 泛型

### 05-26　不用泛型类的原生态类型

(除非你在用JDK5或者更老版本的编译器),否则不要用任何不指定类型的泛型类(如`List strs`)

问题在于这样放弃了编译期安全, 可以向内插入一个Type1的Object,再以Type2取出来,编译时不会有任何报错-运行时才会报错.

虽然向`List<Object>`装入String再取出Long这样的作法还是会报错,但是,至少`List<String>`无法匹配上`List<Object>`这样的参数,反之亦然

#### 方法会传入不知名类型

虽然这种情况很少见,但是还是有的,假设一个方法完全对传入参数类型不感兴趣,只对size感兴趣,该怎么写入参?

写List这样的原生类型固然可以,但是不安全,所以可以用`List<?>`这样的通配符来取代

#### 例外

1. 判断类型的时候得用 List.class这样来获取
2. instanceof 后面还是得接List(PS:但是强制类型转换又是`List<?>`这样转换)

### 05-27 消除非受检(unchecked cast)警告

有时强制类型转换会令编译期爆出一些警告(因为是Object式泛型,不运行没法直接报错), 这个时候, 最好的方式当然是尽量让警告消除.

但是,如果无法消除警告,这个时候有两种选择: 

1. 对自己实力有自信, 可以证明引发警告的代码是安全的(说明java编译期不如你考虑的周全), 大胆使用 `@SuppressWarnings("unchecked")`关掉警告
2. 没法证明引发经过警告的代码是安全的: 这时候应该先理清逻辑, 如果还不行就别关掉了, 免得以后debug找不到问题所在.(大多数时候这样会出问题的)

这个也从另一方面说明动态泛型存在的问题: 约束力不够,编译期检查不健全,有些问题只能留到运行期.

### 05-28 列表优于数组

`List<String>`不是`List<Object>`的子类型,但是`String[]`却是`Object[]`的子类型,所以列表优于数组.

PS: 更像设计缺陷

简单讲: 数组提供了运行时安全,没有编译期安全; 泛型有编译期安全,没有运行期安全. 混合起来就会既没有运行时安全,也没有编译期安全.

### 05-29 优先考虑泛型

虽然大多数情况下使用泛型方法能得到类型安全,但是, 并不是所有情况下都有泛型类可以使用-比如基础库中从零开始写的时候,底层就是数组, 这个时候可以怎么办?

可以从写的方面考虑, 将内置数组声明类型`Object[]`,强制转型`T[]`
或者从读的方面考虑, 每次读取的时候都来一次强制转型.

写的角度来讲,一劳永逸, 只需要参考05-27消除就好(这是建立在证明类型安全的基础上的,否则就堆污染了)
读的角度来说, 很麻烦,但是没有堆污染的可能.