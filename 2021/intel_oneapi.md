<!--
 * @Github: https://github.com/Certseeds/words
 * @Organization: SUSTech
 * @Author: nanoseeds
 * @Date: 2021-09-05 23:58:45
 * @LastEditors: nanoseeds
 * @LastEditTime: 2021-09-06 01:10:05
 * @License: CC-BY-NC-SA_V4_0 or any later version
 -->

# intel-oneapi

最近接触到了intel的加速库,写个小短篇来记录一下.

## 起因

intel一个做CPU的,为什么要做这么多配套的软件库? 什么MKL(Math Kernel Library),IPP(Integrated Performance Primitives)之类的?

### CPU功能的丰富

最初的8008,8080,8085,8086之类的CPU,晶体管数量少,指令集简单,基本上没什么使用的难度,并且当时开发语言也原始,一方面CPU功能少,另一方面大家都几乎在用汇编这种底层代码进行编程,所以对CPU的特性利用的很全面,可以说是相互促进,共同进步.

但是,随着时间推移,CPU中的指令集越加越多,MMX、SSE、SSE2、SSE3、SSSE3、SSE4、AVX、AVX2、AVX-512....指令越加越复杂,另一方面,编程语言越来越高级,越来越`抽象`,剥离底层细节,再加上为了兼容老设备(没有特定指令集),越来越多的软件放弃(或者压根没想过)使用这些特定指令集进行开发.

这样的话,这些高级指令集的实现了但是没人用,岂不是白白浪费资源,甚至竞品(指AMD)把这些不必要的指令集砍了,节省成本来打价格战怎么办?

### 绑定自己客户群体

良好的产品,客户为了更好的体验付费;**的产品,客户为了避免糟糕的体验而付费. intel显然想成为前者, 既然实现了指令集但是没人用,那intel自己出人力来推广自己的指令集不就好了? 这样可以推广之后,逼着竞争对手也得实现相同功能,反正intel财大气粗耗得起这场长跑

### 绑定自己的CPU

更重要的是,一旦intel的生态做起来, 不仅是指令集,而是intel的整套方案都成为了基石, intel肯定不会为竞争对手做测试工作,只会宣称"自己的软件在自己的平台上经过了完整而稳健的测试",无形中排除了竞争对手的存在感.

### 总结

就像Microsoft Office系列为Windows赢来了无可辨别的办公领域需求一样,intel以自己完备的库同样绑定了数量巨大的使用者.

## 实现分析

intel的视角更加底层,intel内部肯定对自己的CPU更熟悉,他们可以通过对CPU内部的了解写出最适合的代码,使用最适合的指令集,考虑最广泛的场景.

### 外部定义好了接口,直接做库

典型为Intel-MKL(Math Kernel Library)数学核心库, BLAS标准定义了矩阵运算类操作的API,在此API的规范下,具体实现层出不穷,比如默认的OpenBLAS(开源),以及Intel-MKL库中的实现. 这一类的好处就在于API公开透明,而且又底层,intel自己只要按照标准打包好库就能进行分发,用户层面只需要改几个环境变量,选定到底链接那几个库就能获取巨大的性能提升.

### 外部没有接口,只能自己暴露API

其实这是一个相对尴尬的场景, 由于外部没有提供好的接口,所以intel自己只能在库内暴露出一些API供调用,但是问题是这些API很难在性能-易用性上做平衡,并且由于intel本身不想开源自己CPU的细节,所以基本只进行二进制分发,这些库不是(并且未来也不会是)开源项目,使用也并不免费(并且需要额外设置需要东西),所以很少有底层开源项目愿意主动接入,怎么办?

intel: 好说! 既然开源项目不适配我们,那我们就反过来适配开源项目! 反正底层库数量就那些,变化也不多.

为此,intel可以说是费劲了心思,无论是底层的压缩库zlib,还是图片处理库GraphicsMagick 都有intel的补丁,打上之后,链接intel-ipp库即可获取数倍的性能提升.

PS: 但是很显然intel还是过于传统了,比如zlib的补丁只提供了Makefile版本的补丁,没有CMake版本的补丁,希望intel能够早日为自己的库提供CMake的Target

PSS: 坑还是有的,比如打了补丁的zlib只能生成动态库,静态库会报错

### 直接入手更底层-自己做编译器

无论是定义接口还是修改其他人的库,层次都还是在代码层面上,能不能再进一步?

当然可以,intel有自己的编译器,在抛弃了兼容性的基础上(指只考虑X86-64,其实有些友商也能用),通过在编译期就默认对某些指令集做出优化,直截了当的获取性能提升,并且这个时候客户也不用考虑什么链接的许可证问题(复杂的动态库,静态库连接许可证需求很让人头痛,有时不得不动态链接一些库,避免被传染到开源协议),毕竟开源许可证中指出,被GCC(GPL2)所编译的代码不会被传染到GPL2许可证.

PS: icc不是另起炉灶,原来基于gcc,现在似乎切换到了LLVM

### 结论

写起来方便和性能,两者不可兼得,大部分开源作者并不想做细微的指令集级别性能优化,intel于是自己亲自下场,修改库来释放自己CPU的加速性能.

正如App Store一定程度上成就了iPhone的传奇,intel的加速库为自己赢得了巨大的护城河,但是这高度依赖于巨大的人力投入(修改各种开源库的实现),万一开源库升级intel一时半会又顶不上,白给的性能就又丢了回去,或许intel还是应该搞一个开源兼容层,搞一搞公有加速标准,方便更多人主动进行优化.
