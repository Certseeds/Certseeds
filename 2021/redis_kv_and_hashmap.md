---
author: "Certseeds"
license: "CC-BY-NC-SA-4.0 or any later version"
date: "2021-08-11"
title: "Redis中的K-V实现与Java中的哈希表对比"
description: "redis kv and hashmap"
tags: ["redis", "java"]
---

# Redis中的K-V实现与Java中的哈希表对比

最近做的项目中接触到了Redis,使用Redis作为缓存,直接将对象序列化后存放到Redis中,从Redis中取出后再反序列化成对象. 单纯从这方面来看,Redis更像是一个外置的HashMap,或者说将服务端的状态抽离了出来,作为单独的服务,提高系统的可用性. 再进一步的讲,如果服务端完全没有任何性能压力,并且只有上述需求的话,甚至可以通过内部的一个`static`的CurrentHashMap来实现. 既然Redis在这个层面与java中的HashMap(后简称HashMap)有相似之处,那么可以通过对两者的对比来发现一些问题.

Redis与HashMap的底层结构是类似的,都是第一维为数组,第二维为链表;

不同之处在于,

第一,

+ 当HashMap中的链表长度到一定值(JDK1.8中为8)的话,会将链表转化为一个红黑树,从而将哈希碰撞的最坏时间复杂度由O(n)转化为O(log(N))
+ 而Redis中始终使用链表,并不会对数组中存储对象的类型做修改.

第二

+ HashMap中扩容操作的容量按照有哪些位置被占用来计算,举例来讲,如果内部数组长度为16,负载因子为0.75,则负载为12,只要有12个数组位置被键占用之后则会触发扩容,引起rehash,但是这里并没有考虑某一个键对应的链表或红黑树有多长;
+ 而Redis中的负载计算方式为整个体系中插入的键值对数量,假设内部数组长度仍为16,Redis(在空闲时)负载因子为1,则内部有16条数据就会触发扩孔,引起rehash

这两种方式相对比,HashMap只考虑内部数组被占用的情况,所以会出现某条链表过长的情况,红黑树的优化是一种必然;而Redis由于考虑全局的键值对数量,所以链表过长也会引起整个数组的扩容与rehash,但是问题又来了,虽然redis负载因子稍微较大,但是这么一来扩容与rehash的频率又要高于HashMap,即使Redis所有数据结构都在内存中,而且是独立的进程,可以预先划分内存池,或者使用内存惰性归还机制,申请新内存空间的成本也不低,Redis又该如何解决此问题?

第三

+ HashMap中的扩容操作是一个立即完成的操作,每当负载触发扩容操作,立马调用扩容函数,对整个数组进行遍历,对链表或红黑树上的节点进行rehash重新排布, 这一步的操作时间可能是比较长的(虽然数组长度一定,但是每个链上的元素实际上没有上限),所以都称HashMap的`put`操作的均摊复杂度为O(1),而不是直接称其为O(1).
+ 而Redis中保存了一新一旧两个Hash结构,使用渐进式的Hash方式,每次触发扩容时建立新的Hash结构,但是不对所有元素进行遍历,而是每有一个请求过来,查询到旧Hash结构中的内容后,将其添加进新的Hash结构,再在旧Hash结构中将其删除,等到旧Hash结构为空将其删除.这种情况下,即使触发扩容操作,所消耗的时间也最多也只用于申请内存,不需要对所有键值对进行遍历,直接将扩容操作的时间均摊到了查询操作中.

在这个角度来看,由于HashMap的负载因子设计原因,插入操作的时间复杂度实际上没有办法得到保证,最坏情况下甚至会到O(n),而Redis由于是外部服务,所以其内部可以由更多的自由,可以通过两个Hash结构来摊平时间上的冲突,当然这时的最坏情况下内存占用会上升到3n左右(n+1时扩容到2n,总共3n+1,但是考虑到数组中存储的都是指针,实际上的内存浪费并不会太多).

本文以Redis与HashMap的相似之处为引子,介绍了Redis与HashMap实现中的不同,分析了其内部设计的一些思路,以及不同定位带来的不同设计结果.

注: 发布于GitHub的本文采取CC-BY-NC-SA-4.0 or any later version,保留在其他平台采取不同许可证的权利-转发链路不同导致的许可证不同问题,请通过到源发布平台转发来解决.