# 基于openpgp的通信

## openpgp的双向通信

在复杂的网络环境中,确认自己发送的信息完整,能够被别人接收到是一件还蛮困难的事情,因此可以采用现代密码学的措施来对通信进行加工,使得信息在流转过程中,即使中途被截获,也无法被解读,强行改写可以被发现.

因此,根据发件人,收件人的性质不同,可以分成以下几种情况

+ Alice给Alice发送信息, 只是利用公共空间保存, 不希望任何人对其细节有所了解.
+ Alice向Bob发送信息, 最多只希望别人直到他们两个之间有沟通,不希望任何人对细节有所了解.
+ Alice向所有人发送信息, 点名批评Bob, 希望所有人都知道这条消息是Alice发送的.

我们接下来依次对这几种情况进行讨论

## Alice的公告

先来讨论比较简单的Alice发送公告的情况, 考虑一下现实中如何对大家公告一件事情.

``` log
OK 兄弟们
全体目光向我看齐嗷
看我看我
我宣布个事儿
BOB是个****
没毛病嗷
```

1. 大家看到真人就能相信是Alice在说话
2. Alice表示了全体目光向我看齐的口号, 号召了大家的眼光
3. 在说话过程中点名批评了Bob, 使得这一个过程变得完整.

+ 如果单纯是一个虚拟人+虚拟音, 大家无法分别是谁在说话
+ 如果什么准备工作也不做, 直接点名批评, 那么没人能听到
+ 如果没有说关键的语句, 宣布个事直接接没毛病,那就没有意义.

因此需要做以下的事情.

1. 需要建立起Alice和公钥的对应关系
+ 线下活动互相交换公钥
  + 其他人给公钥签名(之后讲)
+ 个人网站公布公钥
+ 邮件交互中附带公钥
2. 需要通知大家,不仅让Bob收到,也要让其他人收到
+ 邮件收件人写Bob, 抄送其他人
+ 在Bob的个人网站上填上信息, 并将此页面贴到其他页面
+ 在自己的个人页面上填上信息, 发送到社交媒体上.
3. 写明关键信息, 不要当谜语人

这之后, Alice需要在发出信息之前,对信息使用私钥签名
1. 为了更高效率的传播, 需要确保信息是文本格式的, 不要变成二进制格式
2. 为了避免信息被更改, 需要将信息和签名绑定到一起, 避免两者分离.

脚本可以参考[./openpgp/publish.sh], 会将输入文件加一个`.sign`后缀添加到本地, 可以用这个发送(建议加一个到自己公钥的链接来提高下可信度)

经过测试, 只需要公钥即可`gpg --verify-files`确认签名是被其对应的私钥签署的. 由于这里是明文的,也没什么提取不提取的问题了.

## Alice向Bob发送信息

这个情况下Alice向Bob发出一道讯息, 最多只希望邮件服务商知道有这么个邮件, 完全不希望中途能有人能看懂数据,也不希望有人对数据动手脚.

首先, Alice自己使用自己的私钥对讯息签名, 使用Bob的公钥对讯息进行加密.

+ 使用自己的私钥签名, Bob(或任何人)在线下或者在个人主页获取到Alice的公钥后,可以很方便的确认信息是Alice发出的,中间没有修改过
+ 使用Bob的公钥对讯息进行加密后, 只有Bob自己持有私钥, 可以对讯息解密, 拿到原始数据.

并且为了缩小加密文件的体积,建议产生二进制的文件, 不使用ascii封装产物.

由于这里有加密,签名两个步骤,很难不多想到底顺序是什么, 查阅一些资料后可以得到结果.

1. 如果先加密,再签名, 可能有中间人将其截获, 换一个签名之后使用另一个邮箱发送, **相同信息,发送方不同可以表现出完全不同的语义**.
2. 如果先签名,再加密, 只有收件人能够将其打开, 再使用公钥验证, 这样就不需要防备中间人拦截了.

先签名再加密还有一个好处, 由于无法直接校验发件人, 可以将信息公开, 最典型的例子是隐写成文本,图像之后放置到图书馆内的藏书中.

当然这样也有坏处, 由于是拿对方公钥加密的, 你自己也没法直接看里面的内容, 也没什么办法来校验签名来看看是不是自己签的(如果你忘了的话).