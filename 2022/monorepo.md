---
author: "Certseeds"
date: "2022-04-10"
title: "monorepo"
description: "monorepo"
tags: ["monorepo", "cpp"]
---

# monorepo

## 什么是monorepo?

理论上, 把一些相关联的代码都放到一个版本管理仓库中, 就获得了一个monorepo.

最著名的是FaceBook(or Meta?) & Google, 它们将所有代码都放到同一个仓库里(很显然, 并不是开源的Git, Git支撑不了这么大体量的库)

这里比较重要的是, 这些代码需要相关联. 简单地把两个仓库合并到一起, 让他们的历史记录合并, 并不能取得什么优势. 只有当它们发生联系的时候, 将它们从"物理"层面联系起来才能获取价值

### Monorepo的常见实现

#### Front-End

虽然Monorepo最早在Meta, Google这种企业开始启用, 但是其在一般工业界中的大规模应用, 在前端开发方面最早. 可能是因为前端遇到版本依赖地狱的情况遇到的比较早, 因此较早的去探索解决方案.

#### C++

C++有时被迫将所有依赖库都添加到"third_party"里, 这个不是MonoRepo. 但是考虑到每个项目都要添加一套"third_party", 多个项目共用"third_party"就变成了非常合理的选择. 再加上CMake这个构造工具对于构造子项目有着几乎无限的拓展性, C++项目的Monorepo可以通过层级嵌套子目录的方式来实现.

#### Java

Java的依赖管理比C++要好太多了, 借由Maven, Gradle等工具的存在, 在`pom.xml`中声明依赖后, 构建时可以从主仓库中拉取. 这种情况下项目间不会因为复用依赖而采取monorepo, 而是因为相关联而采取monorepo.

最常见的是使用Maven的parent-modules机制, 将仓库间复用的部分抽象出来, 作为独立模块来被多方所依赖.

## 为什么要使用MonoRepo

### 为了管理第三方依赖

初看这个理由只适合C++, C/C++系的依赖管理总是那么糟糕, 不得不将第三方库都引入自己的仓库中. 为了减少此事的重复发生, 自然倾向于将更多项目结合到一起, 复用第三方依赖管理.

但是, 实际上这个理由也适合Java, 只不过管理的不是"依赖", 而是依赖的"版本".

虽然看上去一般`pom.xml`中的依赖不过数十, 但是层层依赖下去, 实际上依赖的包非常多(但是反正比Js的依赖少), 这些依赖包之间的版本配合, 是一个大问题.

好消息是, Spring-Boot本身对依赖包的版本做了指定, 不需要过多考虑升级, 只需要指定即可; 但是, 在同时存在复数个Spring-Boot项目时, 对这些Spring-Boot项目的升级也变成了噩梦.

再加上管理第三方依赖, 不只是管理进来的这些依赖, 还要管理那些依赖能进, 那些依赖不靠谱不能进. 当使用复数个仓库时, 同一个问题很容易出现多个解决方案; 使用MonoRepo则就会倾向于复用原有的解决方案(当然, 如果原来的就不行, 那就得整个改掉).

### 为了减少沟通成本

以最常见的对外提供RestFul-API的多个项目为例, 一个项目提供的API, 被另外的项目所依赖; 此时, 如果使用多个项目的话, 则需要在每个项目内都建一套VO, 声明键的反序列化字段名, 甚至于实现一套API-Client.

而在使用MonoRepo之后, 这个项目对外提供的API抽象成一个库, 被它自己和其他项目所依赖, 此时, 这些API的VO被多个项目所共用, 因此减少了沟通成本.

### 便于推广最佳实践

比如, MonoRepo提供了复用内部工具方法的方式, (虽然大部分时间, 这些内部工具方法说明架构老旧, 没能引入新库)

再加上具有相同逻辑的一类库, 在使用MonoRepo后, 即可将一些共同的逻辑取长补短.

此处值得点出的事情是, 在做事时, 对于外围(比如配置读取, 注入)处理的越干净, 越对核心逻辑的处理有好处, 可以将可在多平台复用的核心逻辑抽离, 将不能复用的其分离到外围, 复用的整合成真正的核心逻辑.

### 方便不同仓库间依赖管理

不仅有对第三方的依赖, 还有内部的版本依赖. 如果采取mono-repo的方式, 理想状况下, devops采取的好的情况下, 每次发版对所有能发版的子项目都发版一次, 更新版本号, 将其构建后重新部署, 这样消除掉部署的"状态性"之后, 灵活的重新部署, 消除了仓库间依赖管理的问题.
