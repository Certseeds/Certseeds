---
author: "Certseeds"
date: "2022-11-14"
title: "tag and release"
description: "rtag and release"
tags: ["experience", "git"]
---


# tag和release

近期对一个使用git进行版本管理的项目进行了一些改造,这里简单记录一下过程和细节.

## release分支

最早项目中存在两个分支,master-dev,master分支上的提交大多数都带有tag,都是合入了dev分支之后的稳定版本,dev分支负责提交新的功能开发.

在这个情况下,出于锁定依赖,方便使用者开箱即用的思路,将依赖的源码放进了仓库里,源码的体积不大,所以对整个仓库的体积影响也不是太大,看上去似乎还可以接受.

由于项目本身被设计成了一个"模板仓库",不仅是自己开发使用,还要考虑到用户开发使用的场景, 因此需要预设好一些生成出来的模板目录,并将其打包发布出去.但是这些模板仓库在平时开发时没有什么用处,还会时不时的有一些变化,因此不能把他们放到仓库内部,只能以一种"打包时发布"的方式对外发布.

但是打包时发布只能发布出tag以及基于tag的release,并不能干涉github页面上的下载包到底下载了什么,那些只知道点github页面上的下载按钮的人,还是没办法看到生成出来的预设模板目录.

因此, 在对github actions进行了充分调查后,得出了一个结论：既然下载按钮下载到的东西只和git默认分支有关,那么就不应该从默认分支-master打tag创建release包,而是应该在master分支打tag,触发release流程,新建release分支,把所有生成出来的模板目录都添加进去,提交&&`push --force`,并再次基础上进行发出tag的release包.

换句话讲,tag不仅有release产物,还产出了一个release分支作为默认分支,来展示预设目录.

## 使用CMake进行版本管理

由于依赖库的版本更迭的比较快,无论是错误修复或者是新需求开发,都值得更新依赖,因此带来了一个问题: 将依赖合入仓库的时候,铺天盖地的改动>>项目本身的改动,搞得都没办法review了...

在这里有两个方案,第一个是子模块,第二个是改动成cmake-fetchContent的样式.

子模块方式看上去比较简单,但是实际上能带来很多问题,只适合依赖极多的项目(以及没有正儿八经包管理的语言),会往git仓库里面嵌入意义不明的元数据,有时候切换分支一不小心会搞出问题,只能删除本地.git来重建.

cmake-fetchContent的方式则相对有好一些.

+ 对cmake版本有要求,不过现在ubunutu18/20.04默认的cmake版本就够用了
+ IDE兼容不太友好,如果依赖的是git链接的话,ide或者是cmake居然会在加载content的时候自动stash!!! 并且一旦有多个环境(debug/release),就会出现data race的现象,把本地git给搞炸掉.所以最后只能依赖release里的压缩包...
+ 不仅只能依赖压缩包,多个环境还不能同时指定相同的依赖下载位置,不能重复,绝了.

好处在于,在命令行里很顺滑,直接在项目构建器就自动下载,解包,验证依赖.

为了最大程度的避免非开发者的迷惑,给release分支准备了独特的cmake文件,去掉了fetchContent,变为直接把依赖放到third_party里面.

为了适配之前的改动,需要在上面发布release步骤前进行一次`cmake ..`来获取依赖,并且需要把依赖也给添加进release分支的提交里面去.

## tag和release的关系

tag一般是主干分支上打的,但是项目往往需要有第三方依赖,需要生成某些产物,需要进行某些操作等,这些东西都是没法办法直接给加到项目里的(都加进去体积太大).

github平台给出的解决办法是: 为tag生成一个release,不仅会展示自定义的commit-msg,还可以把二进制文件传进去,从而实现tag->github-action(CI)->github release(产物)的过程.

这个过程中,出于对用户友好,以及方便复现的角度,都应该存在一个release分支,作为长期存在的短提交,总是被master上的tag"生成"出来,贴在master分支后面,提供充足的可复现性.
