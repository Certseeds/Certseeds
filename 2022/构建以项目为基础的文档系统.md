---
author: "Certseeds"
date: "2022-05-21"
title: "构建以项目为基础的文档系统"
description: "build document system based on repo"
tags: ["document", "software engineering"]
---

# 构建以项目为基础的文档系统

如上文[./无限拓展的软件架构](http://certseeds.github.io/Certseeds/posts/2022/无限拓展的软件架构)所言,相关联的项目应该放到同一个仓库中进行管理.假设在仓库架构上,已经初步实现了这个设想,那么这个时候,应该如何进行文档系统的管理呢?

## 开源项目如何实现文档的管理

### alibaba:fastjson2

(其作为fastjson的继承者, 也许是为了彻底拜托仓库中残留的大量issue与pull_request,使用了十分狂野的方式来实现继承: 新开一个仓库,仓库名fastjson->fastjson2,版本号上来就是2.0; 就算是go,一般情况下也只是开一个v2分支而已)

以alibaba近期开源的项目 fastjson2 举例, 通过观察其README,可以发现README中不仅初步介绍了仓库的功能,还出现了 `alibaba.github.com/fastjson2/${DOCUMENT}.md`的链接, 点进去之后可以发现页面很简洁,通过链接和整个页面风格能猜测到是github pages(没通过gh-pages分支,而是将master分支的docs目录当作构建的基础). 更仔细观察会发现其实新添加进入仓库的文件都是wiki里的. 相当于将wiki中的,除了有维护权限的人没人能编辑的文档,转移到了仓库中, 以github-pages实现了wiki的功能.

fastjson2的操作对应了趋势: 将文档也纳入版本管理中,将其和代码同步起来,让他们在物理层面上存在同等目录下,拉近他们的关系,确保能访问到代码的人就能看到文档;即使无法对代码做贡献,也能对文档做贡献;只要对代码做了贡献,也有义务保证文档的有效性.

在gitlab中,wiki其实是一个与当前仓库实质上独立,只是通过名称捆绑起来的仓库; 类比到github,和仓库捆绑的紧密程度也高不到哪里去.

PS: 无论是github还是gitlab,wiki的管理都不太行,不是独立的git仓库,没法接受pr,issue,还只有"仅限内部人员编辑"和"所有人都可以编辑"两个极端,确实不好用.

### alibaba:fastjson

fastjson出名已久,可能是由于历史过于久远的原因,再加上项目已进入维护模式,整体项目有超过1500个开启状态的issue和超过100个开启的pull_request. wiki中也有122个页面.

但是这些issue,pull_request和wiki页面并没有使得fastjson处于一个易于理解的状态: 

+ 残留了太多的纯文字描述,完全没有复现细节的issue
+ 有非常多的历史遗留问题的解决pull_request没有被合入,没被管理,也没人重复验证问题是否解决; 
+ 文档虽然有很多页面,但是没有层次结构,只是单纯按字母顺序,还有一些历史版本测试数据这样虽然有意义,但是对于目前版本没有帮助的页面.

更糟糕的是, 旁人对这些帮不上什么忙, 只有仓库所有者能够主动出击,直接了当的要求issue详细也包括复现细节; 要求pull_request不合入就关闭;也只有他们能改动wiki的内容.

wiki和仓库本身的割裂导致其无法同步,wiki本身没有层次化,无法直接观察历史版本又进一步导致了wiki倾向于增加新内容,而非替换旧内容, 这也都导致了文档系统的崩坏.

### catchorg:Catch2

[Catch2](https://github.com/catchorg/Catch2)是一个C++的测试库,以提供Header-Only风格的封装而著称.

catch2本身完全不使用wiki,而是使用`./docs/`子文件夹来存放markdown的文档,并且效果还不错; 得益于仓库本身提供的历史版本管理, 即使仓库本身在进行v2->v3的大版本号更新, 文档系统本身也没冒出来一系列v3文档,而是继续对原有文档进行演进.

## 项目应该怎样有怎样的文档系统.

最原始的文档系统,可以认为是另外一个和仓库本身对应的git仓库; 这种情况下,虽然文档仓库有了版本管理,但是其失去了和项目本身在同一个页面上的机会.

有些时候,会将其迁移到仓库的wiki上,这种情况下虽然在同一个界面上,但是丧失了文档仓库本身的版本管理能力,依然没办法对文档与代码进行对应.

因此,文档应该和代码在相同的仓库中存储,使其能够"双向绑定".

在这种情况下,常见的文档系统中的一些范式也需要发生改变.

+ 在"评估文档","设计文档","实现流程文档","测试文档"为主要流程的新功能上线流程中
  + 整体的前因后果应该在issue中记录,在合入时应该将前因后果整体纳入对应项目的`/docs`中
  + "评估文档"以mini-demo的形式存在,其应该体现为测试部分的mini-demo,以及对应目录README中的手动论证前言部分,论证可行性.
  + "设计文档"部分应该体现在对应目录README中的API文档中,体现在代码里的注释中.
  + "实现流程文档"应当与代码混排,作为注释出现在项目里
  + "测试文档"本身不应该包括数据流程等, 而是在对应测试目录或者对应测试文件对应文档中 对整体测试流程做分析.
  + 测试的数据应该保留在要求合入的pull_request中,或者在pr里以链接的形式存储在外边的ci平台里
+ 以"事件分析报告"为主要流程的BUG追查流程中:
  + 事件分析报告应该首先锁定问题对应的项目,将问题锁定在某个,某几个项目后再分析.
  + 事件分析报告应该以现象来分类,以对问题的锁定为结束.
  + 事件分析报告本身只是分析问题,分析完毕问题后应该以issue启动BUG-FIX流程
+ BUG-FIX流程
  + BUG-FIX流程是由BUG追查流程所引发的,有时时间线会是"本地仓库追查BUG-更新日志"-"主仓库提issue"-"本地仓库修复BUG"-连带追查流程和BUG-FIX一起提交
  + BUG-FIX结束后应该将BUG追查流程的事件分析报告加以标注,注明问题已解决,以及解决版本.

由于文档进入了仓库的管理,和主仓库对应的"本地仓库"就有必要存在,方便对提交的文档进行预览. 而非只搭建中心服务器,不做GUI,没有fork功能; 应该采用的就是pull_request模式,而非gerrit对应的branch-merge模式

### 文档系统应该怎样被展示出来

最好能够采用约定大于配置的方式,采用一定规则,将文档从仓库中抽离出来,映射成为独立的网站. 同时又通过触发机制保证与主分支双向绑定. 从而实现仓库驱动的文档系统.