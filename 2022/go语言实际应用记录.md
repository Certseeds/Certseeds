---
author: "Certseeds"
date: "2022-07-10"
title: "go语言实际应用记录"
description: "using go logs"
tags: ["go", "experience"]
---

# go语言实际应用的记录

## 写个后台进程

写个很常见的服务,启动后加载配置文件,并定期起一个线程,从某些地方拿一些数据,加工后一边打日志,一边把处理结果存到一个数据库内.

### 配置文件

拿go读取配置文件一开始会有点不习惯,因为没有resource这个概念,没办法把配置文件打进包内; 但是,经过短时间回忆,使用`embed`这个功能成功直接把配置文件给嵌入到包体内,成功解决了找不到配置文件的问题.

之后,定义结构体时的tag很有趣,作为纯文本格式的元数据,确实比java的拓展性要好,至少不会让每个开源库都自己造轮子.

模块的init函数很好用! java如果用static 代码块则没法保证执行的顺序(使用前没有办法确保前一个模块也初始好了),如果不使用,则只能靠控制反转,让框架来初始化,之后靠注入来实现. init函数结合大小写控制导出,能实现对外导出结构体时自动确保初始化完成.

相同目录下包必须一样,看起来似乎很普通,但是结合一条:`编译成为二进制文件得类必须是package main&& 具有main函数`,就能确保不把启动类和其他代码混合到一起(当然,到底是走/cmd/projectname/main.go,还是/project/cmd/main.go就是另外一回事了)

### 定时进程

定时进程用了`cron/v3`,启动还挺简单, 但是有一说一,用`select{}`来启动确实很神秘。

定时进程的设置主要靠约定好的规则，要不是数字+时间单位，或者是cron风格的字符串。

### 日志

日志库用了uber开源的zap,可能是考虑到方便把日志介入到后续的处理系统中，默认的日志居然是json格式...，打出的一行一行都是合法的json,绝了。

有可能是模块化吧，至少现在看到的教程内，把构造出来的对象赋给全局对象，然后用`AddCaller()`来声明调用栈. 这点和java常见的每个类声明一个，把`this.getClass()`当入参的完全没什么相似之处。

配置好了全局日志变量和调用栈显示，普通文本格式输出之后，发现zap库是不带日志分片的，需要依赖第三方库来进行。也许是因为uber内部直接能把日志输入到处理系统中，直接对接存储吧。

### 构建

本机执行没什么问题，要部署的话也不需要考虑其他的平台，`CGO_ENABLED=0 GOOS=linux GOARCH=amd64`完事.

部署要是用scratch确实有点难受，关键是没法直接调试，alpine还至少能给个`/bin/sh`，能进镜像内，scratch整个镜像就一个文件......，都没shell可用。

### 目录与私有

internal这个功能应该是为monorepo设计的，java与之类似的设计是java9之后的export导出设置，不过internal是把不想导出的放进去，java是把想要导出的放到声明里。

java是把打包好的二进制包上传供别人使用，可以在这个过程中进行处理，但是go是源码依赖，倾向于从git仓库里把代码拖下来，这种情况下没有internal的限制，就只能靠大小写限制了，太难用了。