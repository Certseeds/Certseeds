## Chapter 05 泛型

### 05-26　不用泛型类的原生态类型

(除非你在用JDK5或者更老版本的编译器),否则不要用任何不指定类型的泛型类(如`List strs`)

问题在于这样放弃了编译期安全, 可以向内插入一个Type1的Object,再以Type2取出来,编译时不会有任何报错-运行时才会报错.

虽然向`List<Object>`装入String再取出Long这样的作法还是会报错,但是,至少`List<String>`无法匹配上`List<Object>`这样的参数,反之亦然

#### 方法会传入不知名类型

虽然这种情况很少见,但是还是有的,假设一个方法完全对传入参数类型不感兴趣,只对size感兴趣,该怎么写入参?

写List这样的原生类型固然可以,但是不安全,所以可以用`List<?>`这样的通配符来取代

#### 例外

1. 判断类型的时候得用 List.class这样来获取
2. instanceof 后面还是得接List(PS:但是强制类型转换又是`List<?>`这样转换)

### 05-27 消除非受检(unchecked cast)警告

有时强制类型转换会令编译期爆出一些警告(因为是Object式泛型,不运行没法直接报错), 这个时候, 最好的方式当然是尽量让警告消除.

但是,如果无法消除警告,这个时候有两种选择: 

1. 对自己实力有自信, 可以证明引发警告的代码是安全的(说明java编译期不如你考虑的周全), 大胆使用 `@SuppressWarnings("unchecked")`关掉警告
2. 没法证明引发经过警告的代码是安全的: 这时候应该先理清逻辑, 如果还不行就别关掉了, 免得以后debug找不到问题所在.(大多数时候这样会出问题的)

这个也从另一方面说明动态泛型存在的问题: 约束力不够,编译期检查不健全,有些问题只能留到运行期.

### 05-28 列表优于数组

`List<String>`不是`List<Object>`的子类型,但是`String[]`却是`Object[]`的子类型,所以列表优于数组.

PS: 更像设计缺陷

简单讲: 数组提供了运行时安全,没有编译期安全; 泛型有编译期安全,没有运行期安全. 混合起来就会既没有运行时安全,也没有编译期安全.

### 05-29 优先考虑泛型

虽然大多数情况下使用泛型方法能得到类型安全,但是, 并不是所有情况下都有泛型类可以使用-比如基础库中从零开始写的时候,底层就是数组, 这个时候可以怎么办?

可以从写的方面考虑, 将内置数组声明类型`Object[]`,强制转型`T[]`
或者从读的方面考虑, 每次读取的时候都来一次强制转型.

写的角度来讲,一劳永逸, 只需要参考05-27消除就好(这是建立在证明类型安全的基础上的,否则就堆污染了)
读的角度来说, 很麻烦,但是没有堆污染的可能.

### 05-30 优先考虑泛型参数

``` java
public static Set union(Set s1,Set s2){
    final Set result = new HashSet(s1);
    result.addAll(s2);
    return result;
}
```

这种函数虽然也能用,但是会报警告,IDE将会发现没泛型参数,不涉及任何类型; 换句话讲, 这个函数描述的不够精确.

|    描述    |                                   签名                                    |
| :--------: | :-----------------------------------------------------------------------: |
| 同类型聚合 |           `public static <T> Set<T> union(Set<T> s1,Set<T> s2)`           |
| 同基类聚合 | `public static <T> Set<T> union(Set<? extents T> s1,Set<? extends T> s2)` |
| 两个类聚合 |         `public static <T, K> Set<T> union(Set<T> s1, Set<K> s2)`         |
| 任何类聚合 |           `public static <?> Set<?> union(Set<?> s1,Set<?> s2)`           |

这样补充上类型参数之后,函数才足够精确,能够描述类型的关系, 足够在编译期进行约束.


### 05-31 利用有限制通配符来提升API的灵活性

这个主要是类库设计者需要考虑的,

比如上面的combine函数, `public static Number Set<Number> union(Set<? extents Number> s1,Set<? extends Number> s2)`实现同基类的聚合,就可以聚合`Set<Integer>,Set<Long>`.

如果要把函数参数当作消费者,需要向容器内插入数据,或让容器接受数据(充当Comsumer), 就需要使用`<? super E>`的方式来实现.

消费者和生产者不同,充当函数内数据产生方的需要使用更泛化的类型,充当数据接收方的要使用更精确的类型.

### 05-32 泛型与可变参数

由于可变参数携带的类型信息不够,所以会破坏反省机制,同时带来隐藏的类型转换.

因此,如果需要传参的话,用了可变参数就别用反省,但是最好还是直接用泛型容器,结合`.of()`方法体验极佳.

PS: 原生数组声明起来确实难看,建议统一使用工厂方法.

### 05-33 类型安全的泛型容器

这个也是库开发者需要考虑的. 大概意思是,可以通过要求用户必要时额外传入泛型信息(iii.class)来实现接口的泛型化.